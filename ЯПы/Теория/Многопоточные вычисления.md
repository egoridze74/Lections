#ЯПы 
## Определения
- **Поток** - минимальная единица выполнения кода
- **Мьютекс** - инструмент для блокировки ресурсов, предотвращающий одновременный доступ
- **Семафор** - управляет доступом к ресурсам, ограничивая количество потоков, которые могут его использовать (мьютекс, но с счётчиком)
- **std::lock_guard** - это инструмент в C++, который автоматически захватывает мьютекс при создании и освобождает его при уничтожении. Применяется в случаях, когда нужно гарантировать, что мьютекс будет освобожден, даже если произойдет ошибка. Используется для упрощения кода, где требуется защита ресурсов в многопоточных программах.
- **std::unique_lock** - тоже работает с мьютексами, но предоставляет больше контроля. Вы можете вручную управлять, когда мьютекс захватывается или освобождается. Также позволяет временно отпускать мьютекс в течение жизни unique_lock. Это полезно в более сложных многопоточных ситуациях, например, когда нужно ожидать какие-то условия, не блокируя другие потоки.
- **Атомарная операция** - операция выполняемая без прерывания
- **Условная переменная (condition variable)** - переменная, которая позволяет потокам ожидать, пока не выполнится определённое условие
- **Пул потоков (thread pool)** - группа предварительно созданных потоков для выполнения задач
## Примеры

- Создание потока
```cpp
#include <thread>
void function() {};
std::thread myThread(function);
```

- Использование мьютекса
```cpp
#include <mutex>
std::mutex mtx;
mtx.lock();
//доступ к общему ресурсу
mtx.unlock();
```

- Использование семафора
```cpp
#include <semaphore>
std::counting_semaphore<10> sem(2);
```

- Реализация атомарных операций
```cpp
#include <atomic>
std::atomic<int> count = 0;
void increment() {
	count++; //Атомарно увеличиваем значение
}
```

- Использование условной переменной
```cpp
#include <condition_variable>
std::mutex mtx();
std::condition_variable cv;
//поток ждёт условия
std::unique_lock<std::mutex> lck(mtx);
cv.wait(lck);
```

- Использование пула потоков
```cpp
#include <vector>
#include <thread>
#include <queue>
#include <functional>

// Вектор для хранения рабочих потоков
std::vector<std::thread> workers;

// Очередь для хранения задач
std::queue<std::function<void()>> tasks;
```
## Проблемы
### Deadlock (взаимная блокировка)
Два потока ждут, пока освободятся ресурсы, занятые друг другом. 
![[Pasted image 20240417115915.png]]
### Race condition (состояние гонки)
Два потока работают с одними и теми же ресурсами, и результат вычислений зависит от порядка выполнения потоков.
![[Pasted image 20240417120450.png]]
### Starvation (голодание)
Когда в многопоточной системе **некоторые поток не получают доступ к ресурсам** из-за того, что **другие потоки постоянно их захватывают**, оставляя "голодающими" потоки без возможности выполнить свои задачи.