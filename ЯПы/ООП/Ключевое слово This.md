Надо знать:
- [[Перегрузка конструкторов класса]]
- [[Указатели. Общая информация]]

# Общая информация

На самом деле мы уже пользовались ключевым словом this. Просто компилятор делал это за нас неявно ( как с конструктором по умолчанию ).

Пусть у нас есть два объекта класса , созданные по шаблону класса. Компилятор выделяет два разных места в памяти для обоих объектов , дает им какие-то адреса. Адрес и хранит ключевое слово this.
- ***This*** - по сути, это константный указатель объекта на самого себя, а.к.а. знание объекта о том, где он в памяти находится.

Снаружи класса this мы использовать не можем, только внутри класса.

# Пример this с перегрузкой конструктора

>class Point {
>	int x;
>	int y;
>	
>public:
>	Point() {
>		x = 0;
>		y = 0;
>		cout << this << " constructor" << endl;
>	}	
>	Point( int valueX , int valueY ) {
>		x = valueX;
>		y = valueY;
>		cout << this << " constructor" << endl;
>	}
>	Print() { как обычно через cout }
>} ;
>
>int main() {
>	Point a;
>	a.Print();     ***// 00ACFF70 constructor***
>	                  ***// x = 0 y = 0***
>	Point b( 4 , 11 );
>	b.Print();     ***// 00FFA770 constructor***
>	                   ***// x = 4 y = 11***
>	return 0;
>}

Вот так вот указатель this хранит адрес объекта в памяти.

# Нафига это нужно?

Компилятор может по адресу объекта в памяти определить, какие для него есть методы. Значит, мы тоже можем это сделать самостоятельно руками.
Вспомним параграф [[Инкапсуляция. Геттеры и сеттеры]]. Там мы писали следующим образом:

>void SetY( int valueY ) {
>	y = valueY;
>}

Мы не могли написать ( у = у ), это бы просто не сработало бы. Однако при помощи ключевого слова This мы можем решить данную проблему:

>void SetY( int y ) {
>	this->y = y;
>}
>------------------------
>int main() {
>	Point a;
>	a.SetY(5);
>	a.Print();       ***// x = 0 y = 5***
>}

( this->y = y ) похож на работу с указателями. Мы поле у инициализируем у-ком из скобок сеттера. 


