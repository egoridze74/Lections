 Надо знать:
- [[Конструктор класса.]]
- [[Ключевое слово This]]
- [[Деструктор. Динамический массив в классе]]

Компилятор определяет конструктор копирования точно так же, как и конструктор по умолчанию - самостоятельно. Если мы его не завели, он все равно в классе присутствует.

# Пример 1 (Функция)

Рассмотрим код:

>class MyClass() {
>public:
>	int data;
>	MyClass( int data ) {
>		this->data = data;
>		cout << "Вызвался конструктор " << this << endl;
>	} 
>	~MyClass() {
>		cout << "Вызвался деструктор " << this << endl;
>	}
>} ;
>
>int main() {
>	setlocale( LC_ALL , "ru" );
>	MyClass a( 1 );
>	return 0;
>}

Получаем:

>Вызвался конструктор 00AFFCA4
>Вызвался деструктор 00AFFCA4

Вроде бы ничего нового...


Теперь между классом и int main() напишем функцию:

>void Foo( MyClass value ) {
>	cout << "Вызвалась функция Foo" << endl;
>}

Получаем :

>Вызвался конструктор 0127FC04    ***// конструктор из main()***
>Вызвалась функция  Foo
>Вызвался деструктор 0127FB20      ***// Что это?***
>Вызвался деструктор 0127FC04      ***// деструктор из main()***

***Почему вызвался какой-то неизвестный деструктор, но соответствующего конструктора не было? Это все деструктор копирования.*** 

# Пример 2 (Функция)

Опишем еще одну функцию вне класса и int main() :

>MyClass Foo2() {
>	cout << "Вызвалась функция Foo_2" << endl;
>	MyClass temp(2);
>	return temp;
>}
>
>int main() {
>	Foo2() ;
>	return 0;
>}

Получаем какую-то страшилку:

>Вызвалась функция Foo_2
>Вызвался конструктор 00EFFDE0       // для temp
>Вызвался деструктор 00EFFDE0         // для temp
>Вызвался деструктор 00EFFE04          ***// ????***

Как это работает? Что за новый деструктор? Это из-за ( return temp ). На месте вызова функции ( Foo2() ) в in main() создается новый объект. Поэтому и вылезает деструктор для него.

# Пример 3 (Динамический массив)

Рассмотрим такой код:

>class MyClass {
>public:
>	int * data;
>	
>	MyClass( int size ) {
>		this->data = new int[size];
>		for ( int i = 0 ; i < size ; i++  ) {
>				data[i] = i;
>		}
>		cout << "Вызвался конструктор " << this << endl;
>	}
>	
>	~MyClass() {
>		delete[] data;
>		cout << "Вызвался деструктор " << this << endl;
>	}
>} ;
>
>int main() {
>	setlocale( LC_ALL , "ru" );
>	MyClass a( 10 );
>	MyClass b( a );       ***// работаем с копией а***
>	return 0;
>}

Скомпилировав этот код, мы получим ошибку. Почему? У нас есть два объекта, которые указывают на одно и то же место в памяти. Мы при помощи деструктора чистим память за одним из объектов. Но потом пытаемся очистить эту же память еще раз уже за другим объектом. 

# Конструктор копирования

Вот поэтому и используется конструктор копирования.

>private:
>	int Size;
>public:
>
>	int * data;
>	
>	MyClass( int size ) {
>		this->Size = size;
>		this->data = new int[size];
>		for ( int i = 0 ; i < size ; i++ ) { data[i] = i; }
>		cout << "Вызвался конструктор " << this << endl;
>	}
>	
>	MyClass ( const MyClass &other ) {
>		this->Size = other.Size;
>		this->data = new int [other.Size];
>		for ( int i = 0; i < other.Size ; i++ ) { 
>			this->data[i] = other.data[i]; 
>		}
>		cout << "Вызвался конструктор копирования " << this << endl;
>	}
>	
>	~MyClass() {
>		cout << "Вызвался деструктор " << this << endl;
>		delete[] data;
>	}