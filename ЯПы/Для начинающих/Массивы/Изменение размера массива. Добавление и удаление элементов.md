Необходимо знать:
- [[Динамический массив. Общая информация]]
- [[Динамическая память. Утечка памяти. Стек и куча. Статическая память.]]
- [[Копирование динамического массива]]
- [[Указатели. Общая информация]]
- [[Ссылки. Общая информация]]

# Общая информация

Нам известно, что массив в памяти хранится непрерывно, то есть каждая его ячейка идет одна за другой по порядку. Поэтому возникают проблемы в изменении массива.

Как надо работать? Принцип похож на тот, что здесь: [[Копирование динамического массива]]

***Если мы хотим добавить элемент:***
1. Создаем новый массив, который больше на то кол-во элементов, на которое мы хотим изменить.
2. Через цикл закидываем элементы из старого массива в новый.
3. Добавляем новые значения.
4. Старый массив удаляем.
5. Указатель в нашей программе теперь должен указывать не на старый массив, а на новый ( меняем адрес указателя ).

С удалением элементов немного сложнее.
***Пусть мы хотим удалить первый элемент. Мы не можем присвоить указателю значение второго элемента, а на первый забить, т.к. произойдет утечка памяти.***
Аналогично с удалением последнего элемента. С удалением элемента из другой части массива проблем еще больше. Итог всегда один - утечка.

Решение? Как и до этого: создание нового массива , копирование элементов из старого в новый , удаление старого.

# Добавление в конец массив нового элемента

Здесь будут использоваться функции заполнения и вывода массивов отсюда: [[Константные аргументы функции. Константный указатель. Константные параметры.]]

Далее будет много кода...

>void push_back( int * &arr , int &size , const int value ) {
>	int * newArray = new int[size + 1];        ***// создаем новый массив***
>	for ( int i = 0 ; i < size ; i++ ) {                ***// переносим старые значения***
>		newArray[i] = arr[i];
>	}
>	newArray[size] = value;                         ***// в последнюю ячейку кидаем значение***
>	size++;                                                  ***// увеличиваем размер массива***
>	delete [] arr;                                          ***// чистим старый массив***
>	arr = newArray;                                    ***// в указатель присваиваем адрес нового массива***
>}
>
>int main() {
>	int size = 5;
>	int * arr = new int[size];            ***// создаем массив***
>	FillArray( arr , size );                  ***// заполняем массив*** 
>	push_back( arr , size , 111 );     ***// функция добавления нового элемента 111***
>	ShowArray( arr , size );
>	delete [] arr;
>}

Разберем аргументы функции push_back( ):
- ***const int value*** - какое-то новое значение, которое будет находится в новой самой правой ячейке.
- ***int &size*** - ссылка на значение размера массива, которое мы будем использовать для добавления нового элемента, а затем увеличения size на 1.
- ***int * &arr*** - ссылка на указатель массива arr.

# Удаление последнего элемента массива

Код будет похожий:

>void pop_back( int * & arr , int &size ) {
>	size--;
>	int * newArray = new int[size];
>	for ( int i = 0 ; i < size ; i++ ) {
>		newArray[i] = arr[i];
>	}
>	delete[] arr;
>	arr = newArray;
>}
