Надо знать:
- [[Динамический массив. Общая информация]]
- [[Константные аргументы функции. Константный указатель. Константные параметры.]]
- [[Динамическая память. Утечка памяти. Стек и куча. Статическая память.]]
- [[New. Delete. Работа с динамической памятью]]

Пусть у нас есть переменные ( a = 2 ) и ( b = 3 ). Когда мы пишем a = b, то в переменную a закидывается значение 3, а 2 уходит в небытие (((.

Рассмотрим аналогичную ситуацию с массивами. Пусть у нас есть array1 и array2. Не забываем, что массив - указатель на область динамической памяти. Поэтому если мы напишем array1 = array2 , ничего хорошего не произойдет. 
***А именно: массив array1 будет указывать на первую ячейку массива array2. НО ЕГО ИЗНАЧАЛЬНЫЕ ЗНАЧЕНИЯ ОСТАНУТСЯ ВИСЕТЬ В ПАМЯТИ. Итог: утечка памяти. Вернуть доступ к ним никак не получится. (((***

Также следует отметить, что мы получим два указателя, которые указывают на одну область в оперативной памяти. Если мы напишем ( array1[0] = 55 ) , а затем спросим, что лежит в array2[0] , то получим тот же 55.

***Как же надо работать?***
1. Удаляем при помощи delete место в ОП, которое ранее занимал array1.
2. С помощью new для array1 выделяем новое место в ОП, равное размеру array2 ( имеет столько же ячеек ).
3. Пробежаться циклом по array2 , из каждой ячейки вытащить данные и присвоить их каждому элементу нового массива.

Рассмотрим пример правильного копирования:

>int main() {
>	int size = 10;
>	int * firstArray = new int [size];
>	int * secondArray = new int [size];
>	
>	( тут задаем значения массивов для копирования )
>	
>	***delete[]firstArray;     // удаляем из памяти 1ый массив***
>	***firstArray = new int[size];    // выделяем новое место***
>	for ( int i = 0 ; i < size ; ++i ) {
>		firstArray[i] = secondArray[i];    ***// копирование***
>	}
>	
>	delete[]firstArray;
>	delete[]secondArray;
>}

В коде можно использовать функции заполнения и вывода массивов отсюда: [[Константные аргументы функции. Константный указатель. Константные параметры.]]