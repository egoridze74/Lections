Будет полезно вспомнить про [[Указатели. Общая информация]] .
# Передача и возврат одного аргумента

Рассмотрим следующий код.

>#include < iostream>
>using namespace std;
>
>void f( int * pa ) { ( * pa )++; }
>
>int main() {
>	int a = 0;
>	cout << a << endl;      ***// 0***
>	f( &a );
>	cout << a << endl;v     ***// 1***
>}

Передаем в качестве аргумента функции указатель на переменную а.
Если бы работали без указателя, то получили в качестве ответов 0 , 0. 
Почитать про указатели можно здесь: [[Указатели. Общая информация]]

Рассмотрим другой код, уже без указателя.

>#include < iostream>
>using namespace std;
>
>void f( int a ) { a++; }
>
>int main() {
>	int a = 0;
>	cout << a << endl;      ***// 0***
>	f( a );
>	cout << a << endl;v     ***// 0***
>}

Почему мы здесь получаем два нуля? Когда мы пишем void f( int a ), это означает, что мы работаем не с переменной а, а с ее значением, т.е. с нулем. Получаем, что внутри функции теперь а = 1, однако в main() изменений не произошло ( опять же, потому что мы изменили ее значение только внутри функции, но не внутри main() ).

# Передача и возврат нескольких значений 

Рассмотрим следующий код:

>#include < iostream>
>using namespace std;
>
>void f( int * pa , int * pb , int * ca ) {
>	* pa = 555;
>	( * pb ) ++;
>	* pc = -20;
>}
>
>int main() {
>	int a = 0 , b = 0 , c = 1;
>	cout << a << endl;      ***// 0***
>	cout << b << endl;      ***// 0***
>	cout << c << endl;      ***// 1***
>	f( &a , &b , &c );
>	cout << a << endl;      ***// 555***
>	cout << b << endl;      ***// 1***
>	cout << c << endl;      ***// -20***
>}

По большому счету принцип работы аналогичный. Описан выше.
