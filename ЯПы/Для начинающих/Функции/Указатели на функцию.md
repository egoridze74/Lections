Надо знать:
- [[Указатели. Общая информация]]

- Указатель на функцию - это фактически переменная , в которую мы можем присвоить ссылку на функцию.
- Проще: это переменная , в которую мы можем засунуть функцию ( присвоить ее туда , а потом из этой переменной вызвать ).
# Простые примеры без аргументов

Выглядит это следующим образом:

>тип функции( * имя указателя )( спецификация параметров )

Рассмотрим следующий код:

>void Foo1() { cout << "void Foo 1()" << endl; }
>void Foo2() { cout << "void Foo 2()" << endl; }
>
>int main() {
>	void ( * fooPointer1 )();    ***// создали указатель, Которому мы можем присвоить адрес функции , которая возвращает void и не принимает никаких параметров.*** 
>	fooPointer = Foo1;
>	fooPointer();              ***// void Foo 1()***
>}

При запуске мы получаем ( void Foo1() ) , хотя функцию Foo1 мы нигде не вызываем. ***Мы просто присвоили ссылку на эту функцию в указатель на функцию.***

Если мы попробуем задать функцию следующим образом, то получим ошибку, т.к. функция не должна принимать никаких аргументов.

>void Foo1( int a ) { ... }          ***- ошибка***

Чтобы не было ошибки, надо в указателе написать, что будет аргумент:

>int main() {
>	void ( * fooPointer )( int a );
>	fooPointer = Foo1;
>	fooPointer( 5 );
>}

# Примеры с аргументами

Рассмотрим такой код:

>int Foo1( int a ) { return a - 1 ; }
>int Foo2( int a ) { return a * 2 ; }
>
>int main() {
>	int ( * fooPointer )( int a );
>	
>	fooPointer = Foo1;
>	cout << fooPointer( 5 ) << endl;      ***// 4***
>	
>	fooPointer = Foo2;
>	cout << fooPointer( 5 ) << endl;      ***// 10***
>}

Вызвали бы просто функцию без указателю, жили бы спокойно... Зачем это нужно?
Да хер его знает , я не вижу никакой разницы между указателем и [[Шаблонные функции. Template typename. Template class]] , потому что по сути принцип работы аналогичный... я устал :-(