Необходимо знать:
- [[Указатели. Общая информация]]
- [[Арифметика указателей. Указатели и массивы]]
- [[Введение в строки. Char. Нуль терминатор]]
- [[Динамический массив. Общая информация]]

Рассмотрим следующий код:

>int main() {
>	const char * string = "Hello!";
>	cout << string << endl;     ***// Hello!***
>}

Мы избавились от записи ( char str[] = "Hello!"; ), которая была здесь:[[Введение в строки. Char. Нуль терминатор]].

Мы также можем писать и так:

>int main() {
>	char str[] = "Hello!";
>	char * string = str;
>	cout << string << endl;     ***// Hello!***
>}

Работать со строками мы можем в точности так же, как и с динамическими массивами.

>int main() {
>	const char * strArr[] = { "Hello" , "World" , "TEST" };
>	for ( int i = 0 ; i < 3 ; i++ ) { cout << strArr[i] << endl; } 
>}


Можно, как и с массивами, указатели на строки использовать в качестве аргументов функции:

>void foo( const char * str ) { cout << strlen( str ) << endl; }
>
>int main() {
>	const char * str = "Hello!";
>	foo( str );                       ***// 5***
>}

На самом деле, со строками происходит какая-то херня... То, что работает логично с массивами, работает хер пойми как в строках. Взять, например, строку ( cout << strlen( str ) << endl; ). Почему перед ( str ) не стоит ( * ) ? Вопрос хороший.

Да и в целом этот параграф какое-то говно :-(

Короче мораль такова: название строки работает как ссылка. Но это не точно...