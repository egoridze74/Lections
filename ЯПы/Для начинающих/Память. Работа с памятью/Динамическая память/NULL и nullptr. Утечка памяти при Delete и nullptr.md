Здесь будет рассматриваться информация, а также код отсюда:
- [[New. Delete. Работа с динамической памятью]].

# NULL

- ***NULL - это макрос, который записан через # define как 0.*** 
Поэтому разницы нет между ( a = 0 ) и ( a = NULL ).

>int main() {
>	int * pa = new int;
>	* pa = 10;
>	cout << * pa << endl;      // 10
>	***delete pa;***                          // таким образом производится очистка ячейки
>	
>	***pa = NULL;***                       // очищаем номер ячейки
>}

# nullptr

- ***nullptr - отдельный тип данных, а не целочисленный int-овый ноль. Его также можно использовать для очистки указателя.*** 
Поэтому лучше всего использовать именно его, а не NULL, для очистки указателя от номера ячейки в памяти.

>int main() {
>	int * pa = new int;
>	* pa = 10;
>	cout << * pa << endl;      // 10
>	***delete pa;***                          // таким образом производится очистка ячейки
>	
>	***pa = nullptr;***                       // очищаем номер ячейки
>}

# Утечка памяти при Delete и nullptr

***В коде при очистке динамической памяти обязательно сначала надо использовать delete pa, а затем - ( pa = nullptr ).
В противном случае может произойти утечка памяти.***

>int main() {
>	int * pa = new int;
>	* pa = 10;
>	cout << * pa << endl;      // 10
>	***delete pa;***                          // таким образом производится очистка ячейки
>	
>	***pa = nullptr;***                       // очищаем номер ячейки
>}

Представлен правильный порядок.

***Почему может случиться утечка памяти?***
Если сначала напишем ( pa = nullptr ), то мы удалим адрес, по которому могли бы найти динамическую память. Но т.к. адрес удален безвозвратно, то ее мы найти и удалить не можем, а значит от ( delete pa ) смысла нет, и эта область останется в оперативной памяти навсегда до ее утечки.