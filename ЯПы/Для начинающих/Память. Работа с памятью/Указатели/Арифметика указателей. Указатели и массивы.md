Полезно вспомнить: [[Указатели. Общая информация]]
# Массив - это указатель

Напишем код, в котором заводим массив на 5 значений и выводим его элементы.

>int main() {
>	const int SIZE = 5;
>	int arr[SIZE] = { 4 , 55 , 79 , 1 , 4 }
>	for ( int i = 0; i < SIZE; ++i ) { cout << arr[i] << " "; }
>}

НО: ***Имя массива - это указатель на его первый по счету элемент ( т.е. нулевой ).***
Откуда мы можем написать:

>int * pArr = arr;        ***// присвоили ссылку на наш массив***
>int arr[SIZE] = { 4 , 55 , 79 , 1 , 4 }    ***// идентичная запись***

***Нам не надо ставить знак &, потому что имя массива - это уже указатель.***

>int main() {
>	const int SIZE = 5;
>	int arr[SIZE] = { 4 , 55 , 79 , 1 , 4 }
>	int * pArr = arr; 
>	cout << arr << endl;            // получим два одинаковых ответа, а именно - адреса ячеек в  
>	cout << pArr << endl;             16-ричной системе счисления
>}

# Арифметика указателей

Мы можем обратиться к 0-ому элементу массива Следующим образом:

>int main() {
>	const int SIZE = 5;
>	int arr[SIZE] = { 4 , 55 , 79 , 1 , 4 }
>	cout << * arr << endl;                     ***// 4***
>}

Если мы хотим обратиться к другим элементам, то пишем так:

>int main() {
>	const int SIZE = 5;
>	int arr[SIZE] = { 4 , 55 , 79 , 1 , 4 }
>	cout << * ( arr + 1 ) << endl;                     ***// 55***
>	cout << * ( arr + 2 ) << endl;                     ***// 79***
>}


![[Pasted image 20231028165653.png]]

Таким образом можно по-другому написать привычный перебор элементов, добавив лишь * перед ( arr + i ). Но без * мы получаем вывод номеров ячеек, в который находятся элементы. 
***Можно заметить, что они идут с шагом 4, т.к. мы работаем с массивом типа int.***
***Т.е. к адресу нулевого элемента мы прибавляем 0 , 1 , 2 , ... ( i у нас типа int, поэтому номера ячеек отличаются на 4 ).***
