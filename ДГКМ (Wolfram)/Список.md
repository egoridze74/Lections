#дгкм 
## Особенности
- В списке woflram могут быть любые объекты, в одном списке могут быть различные объекты
- Нумерация начинается с 1
- Списки могут быть многоуровневыми, при этом они необязательно должны быть одинаковыми
- функции почти всегда не меняют аргумент, а просто возвращают новый список
## Создание списка
```wolfram
 in[1]: l = {a, 1, b, 2}
out[1]:
```
### Обращение к элементу
```wolfram
l[[2]] # обращение к элементу
Part[l, 2] # то же самое
```
### В многоуровневых
```wolfram
l1 = {{1, 2}, {3}}
l1[[1, 2]] # обращение к первому подсписку, второму элементу
```
### Функция Flatten
```wolfram
l2 = l1 // Flatten
```

## Сложение и умножение в списке
Оно происходит поэлементно, **в целом все функции перегружены так, чтобы применяться на каждом элементе** 
```wolfram
l1 = {1, 2}
l2 = {2, 3}
l1 + l2 = {3, 5}
```

##
Для того, чтобы перегрузить свою функцию так, чтобы она применялась к каждому элементу, нужно использовать:
- ```Map[g, 1]
- ```g /@ l
- ```Plus @@ l```
## Рекурсивное использование функции
```wolfarm
Nest(g, l, 3)
```
Применит $g$ к $l$ 3 раза

## Длина списка
```wolfram
length[l]
```
При использовании к многоуровневому массиву, выдает только размер внешнего списка
```wolfram
Dimensions[l]
```
Выдает размер других массивов

## Вставить элемент в список
``` wolfram
Insert[1, q, {{3}, {5}}]
{a, 1, b, 2}
Append[1, 0]
{a, 1, b, 2, 0}
Prepend[1, 4]
{4, a, 1, b, 2, 0}
list = {a, 1, b, 2}
AppendTo[list, 11]
{a, 1, b, 2, 11}
PrependTo[list, -11]
{-11, a, 1, b, 2, 11}
Riffle[list, t]
{-11, t, a, t, 1, t, b, t, 2, t, 11}
```
## Выбор элементов
``` wolfram
Most[list] - без последнего
{-11, a, 1, b, 2}
Rest[list] - без первого
{a, 1, b, 2, 11}
Take[list, {2, 4}] - выбрать с такого по такой
{a, 1, b}
list[[2;;4]] - короткая форма Take
Drop[list, {2, 4}] - всё, кроме с такого по такой
{-11, 2, 11}
TakeDrop[list, {2, 4}] - обе функции
{{a, 1, b}, {-11, 2, 11}}
```
## Сдвиг элементов
``` wolfram
RotateLeft[list, 1] - сдвинуть влево на 1
{a, 1, b, 2, 11, -11}
RotateRight[list, 1] - сдвинуть вправо на 1
{11, -11, a, 1, b, 2}
Reverse@list - развернуть список
{11, 2, b, 1, a, -11}
```
## Выбор элементов по правилу
``` wolfram
f[x_] := If[x < 0, True, False]
f[1]
Выдаст False
f[-1]
Выдаст True
Select[list, f] - выбор из списка по функции f
{-11}
Select[l, # < 0&] - можно вставить в селект лямбда-функцию
```
## Лямбда-функции (чистые)
``` wolfram
2#+5&[1]
```
& - значит что всё, что было до него - **лямбда (чистая) функция**
$\#$ - значит, что вместо решётки нужно подставить аргумент

Можно применять лямбда-функции к списку:
``` wolfram
10^#&/@Range[5] - после собаки можно вставить список
```
## Шаблонные проверки
``` wolfram
MatchQ[1, _Integer] - первый параметр - аргумент, второй - шаблон
Select[list, MatchQ[__?Negative]]
```
## Прикольный пример
``` wolfram
y[x_Symbol, z__Integer] := Apply[Times, x^{z}] - вместо Times можно вписывать функцию, которая будет применяться
y[2, 2] - выдаст y[2, 2]
y[x, 2] - выдаст x^2
y[x, 2, 3] - x^5
```
## Функции замены
``` wolfram
list/._?Negative :-> 0 - заменит все отрицательные числа на 0
list/._?f :-> 0 - вместо Negative можно применять свою функцию
```
## Поиск индекса элемента
``` wolfram
Position[list, a] - ищем позицию элемента a
Min[list], Max[list] - выдаёт минимум и максимум
```
## Сортировка
``` wolfram
Sort[Range[5], Greater] - сортировка по убыванию
```
## Рандомные числа
``` wolfram
RandomInteger[{-5, 5}, 15] - первый аргумент - диапазон, второй - количество
Можно делать двухуровневые списки
RandomReal[{-5, 5}, {15, 3}] - во втором аргументе пишем, что нужно 15 списков по 3 элемента 
```
## Module
``` wolfram
h[a_, b_] := Module[{лок_перем_1, лок_перем_2, ...}, действие_1; действие_2; действие_3; ...; вывод]
s[x_, y_] := Module[{y}, y = x^2; Max[Abs[y]]] - возведёт элементы в квадрат и найдёт макс по модулю
```